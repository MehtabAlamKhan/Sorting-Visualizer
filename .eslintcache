[{"D:\\games\\Projects\\sv-my\\src\\index.js":"1","D:\\games\\Projects\\sv-my\\src\\App.js":"2","D:\\games\\Projects\\sv-my\\src\\reportWebVitals.js":"3","D:\\games\\Projects\\sv-my\\src\\Components\\SortingVisualizer.jsx":"4","D:\\games\\Projects\\sv-my\\src\\Components\\SortingAlogorithms.js":"5"},{"size":500,"mtime":499162500000,"results":"6","hashOfConfig":"7"},{"size":224,"mtime":1610270563714,"results":"8","hashOfConfig":"7"},{"size":362,"mtime":499162500000,"results":"9","hashOfConfig":"7"},{"size":13827,"mtime":1610384317997,"results":"10","hashOfConfig":"7"},{"size":9011,"mtime":1610373471926,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"bn39cx",{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"21","messages":"22","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23"},"D:\\games\\Projects\\sv-my\\src\\index.js",[],["24","25"],"D:\\games\\Projects\\sv-my\\src\\App.js",[],"D:\\games\\Projects\\sv-my\\src\\reportWebVitals.js",[],"D:\\games\\Projects\\sv-my\\src\\Components\\SortingVisualizer.jsx",["26","27","28"],"D:\\games\\Projects\\sv-my\\src\\Components\\SortingAlogorithms.js",["29"],"//-----------------------------INSERTION SORT-----------------------------\r\nexport function insertionSortCall(arrayn, order) {\r\n  const animations = [];\r\n  insertionSort(arrayn, animations, order);\r\n  // console.log(order);\r\n  return animations;\r\n}\r\n\r\nfunction insertionSort(array, animations, order) {\r\n  for (var i = 1; i < array.length; i++) {\r\n    let current = array[i];\r\n    var j = i - 1;\r\n    animations.push([i, j]);\r\n    animations.push([i, j]);\r\n    if (order === \"asc\") {\r\n      while (j >= 0 && array[j] > current) {\r\n        array[j + 1] = array[j];\r\n\r\n        animations.push([j + 1, j]);\r\n        animations.push([j + 1, j]);\r\n        animations.push([j + 1, j, array[j + 1], current]);\r\n        j--;\r\n      }\r\n    } else {\r\n      while (j >= 0 && array[j] < current) {\r\n        array[j + 1] = array[j];\r\n\r\n        animations.push([j + 1, j]);\r\n        animations.push([j + 1, j]);\r\n        animations.push([j + 1, j, array[j + 1], current]);\r\n        j--;\r\n      }\r\n    }\r\n    array[j + 1] = current;\r\n    animations.push([j + 1, current, 0]);\r\n  }\r\n}\r\n\r\n//-------------------------------BUBBLE SORT-----------------------------\r\nexport function bubbleSortCall(array, order) {\r\n  const animation = [];\r\n  bubbleSort(array, animation, order);\r\n  return animation;\r\n}\r\n\r\nfunction bubbleSort(array, animation, order) {\r\n  for (var i = 0; i < array.length; i++) {\r\n    for (var j = 1; j < array.length - i; j++) {\r\n      animation.push([j - 1, j]);\r\n      animation.push([j - 1, j]);\r\n      if (order === \"asc\") {\r\n        if (array[j - 1] > array[j]) {\r\n          let temp = array[j - 1];\r\n          array[j - 1] = array[j];\r\n          array[j] = temp;\r\n          animation.push([j - 1, j, array[j - 1], array[j]]);\r\n        } else {\r\n          animation.push([j - 1, j, array[j - 1], array[j]]);\r\n        }\r\n      } else {\r\n        if (array[j - 1] < array[j]) {\r\n          let temp = array[j - 1];\r\n          array[j - 1] = array[j];\r\n          array[j] = temp;\r\n          animation.push([j - 1, j, array[j - 1], array[j]]);\r\n        } else {\r\n          animation.push([j - 1, j, array[j - 1], array[j]]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n//-------------------------------HEAP SORT----------------------------------\r\nvar length;\r\n/* to create MAX  array */\r\nexport function heapSortCall(array, order) {\r\n  const animations = [];\r\n  heapSort(array, animations, order);\r\n  return animations;\r\n}\r\n\r\nfunction heapSort(array, animations, order) {\r\n  length = array.length;\r\n\r\n  for (var i = Math.floor(length / 2); i >= 0; i -= 1) {\r\n    heap_root(array, animations, i, order);\r\n  }\r\n\r\n  for (i = array.length - 1; i > 0; i--) {\r\n    swap(array, 0, i);\r\n    length--;\r\n    animations.push([0, i, array[0], array[i]]);\r\n\r\n    heap_root(array, animations, 0, order);\r\n  }\r\n}\r\n\r\nfunction heap_root(array, animations, i, order) {\r\n  var l = 2 * i + 1;\r\n  var r = 2 * i + 2;\r\n  var largest = i;\r\n\r\n  if (order === \"asc\") {\r\n    if (l < length && array[l] > array[largest]) {\r\n      largest = l;\r\n      animations.push([i, l]);\r\n      animations.push([i, l]);\r\n    }\r\n\r\n    if (r < length && array[r] > array[largest]) {\r\n      largest = r;\r\n      animations.push([i, r]);\r\n      animations.push([i, r]);\r\n    }\r\n  }else{\r\n    \r\n    if (l < length && array[l] < array[largest]) {\r\n      largest = l;\r\n      animations.push([i, l]);\r\n      animations.push([i, l]);\r\n    }\r\n  \r\n    if (r < length && array[r] < array[largest]) {\r\n      largest = r;\r\n      animations.push([i, r]);\r\n      animations.push([i, r]);\r\n    }\r\n  }\r\n\r\n  if (largest != i) {\r\n    swap(array, i, largest);\r\n    animations.push([i, largest, array[i], array[largest], 0]);\r\n    heap_root(array, animations, largest,order);\r\n  }\r\n}\r\n\r\nfunction swap(input, index_A, index_B) {\r\n  var temp = input[index_A];\r\n\r\n  input[index_A] = input[index_B];\r\n  input[index_B] = temp;\r\n}\r\n\r\n//----------------------------------QUICKSORT-----------------------------------\r\nexport function QuickSortCall(array,order) {\r\n  const ani = {\r\n    animation: [],\r\n    animation2: [],\r\n  };\r\n\r\n  var l = 0;\r\n  var h = array.length;\r\n  QuickSort(array, l, h, ani.animation, ani.animation2,order);\r\n  return ani;\r\n}\r\n\r\nfunction QuickSort(array, l, h, animation, animation2,order) {\r\n  if (l < h) {\r\n    var j = partition(array, l, h, animation, animation2,order);\r\n\r\n    QuickSort(array, l, j, animation, animation2,order);\r\n    QuickSort(array, j + 1, h, animation, animation2,order);\r\n  }\r\n}\r\n\r\nfunction partition(array, l, h, animation, animation2,order) {\r\n  const pivot = array[l];\r\n  var i = l;\r\n  var j = h;\r\n\r\n  while (i < j) {\r\n    if(order==='asc'){\r\n      do {\r\n        i++;\r\n        animation2.push(i);\r\n        animation2.push(i);\r\n      } while (array[i] <= pivot);\r\n      do {\r\n        j--;\r\n        animation2.push(j);\r\n        animation2.push(j);\r\n      } while (array[j] > pivot);\r\n    }\r\n    else{\r\n      do {\r\n        i++;\r\n        animation2.push(i);\r\n        animation2.push(i);\r\n      } while (array[i] >= pivot);\r\n      do {\r\n        j--;\r\n        animation2.push(j);\r\n        animation2.push(j);\r\n      } while (array[j] < pivot);\r\n    }\r\n    if (i < j) {\r\n      animation.push([i, j]);\r\n      animation.push([i, j]);\r\n      // animation.push([i, j, array[i], array[j]]);\r\n      let temp = array[i];\r\n      array[i] = array[j];\r\n      array[j] = temp;\r\n    }\r\n  }\r\n\r\n  let temp = array[l];\r\n  array[l] = array[j];\r\n  array[j] = temp;\r\n\r\n  animation.push([l, j]);\r\n  animation.push([l, j]);\r\n  animation.push([l, j, array[l], array[j]]);\r\n\r\n  return j;\r\n}\r\n\r\n//---------------------------------------------MERGE SORT-----------------------------------------------------//\r\n\r\nexport function mergeSort(array,order) {\r\n  const animations = [];\r\n  if (array.length <= 1) return array;\r\n  const auxiliaryArray = array.slice();\r\n  mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations,order);\r\n  return animations;\r\n}\r\n\r\nfunction mergeSortHelper(\r\n  mainArray,\r\n  startIdx,\r\n  endIdx,\r\n  auxiliaryArray,\r\n  animations,order\r\n) {\r\n  if (startIdx === endIdx) return;\r\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\r\n  mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations,order);\r\n  mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations,order);\r\n  doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations,order);\r\n}\r\n\r\nfunction doMerge(\r\n  mainArray,\r\n  startIdx,\r\n  middleIdx,\r\n  endIdx,\r\n  auxiliaryArray,\r\n  animations,order\r\n) {\r\n  let k = startIdx;\r\n  let i = startIdx;\r\n  let j = middleIdx + 1;\r\n  while (i <= middleIdx && j <= endIdx) {\r\n    // These are the values that we're comparing; we push them once\r\n    // to change their color.\r\n    animations.push([i, j]);\r\n    // These are the values that we're comparing; we push them a second\r\n    // time to revert their color.\r\n    animations.push([i, j]);\r\n    if(order==='asc'){\r\n      if (auxiliaryArray[i] <= auxiliaryArray[j]) {\r\n        // We overwrite the value at index k in the original array with the\r\n        // value at index i in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[i]]);\r\n        mainArray[k++] = auxiliaryArray[i++];\r\n      } else {\r\n        // We overwrite the value at index k in the original array with the\r\n        // value at index j in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[j]]);\r\n        mainArray[k++] = auxiliaryArray[j++];\r\n      }\r\n    }else{\r\n      if (auxiliaryArray[i] >= auxiliaryArray[j]) {\r\n        // We overwrite the value at index k in the original array with the\r\n        // value at index i in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[i]]);\r\n        mainArray[k++] = auxiliaryArray[i++];\r\n      } else {\r\n        // We overwrite the value at index k in the original array with the\r\n        // value at index j in the auxiliary array.\r\n        animations.push([k, auxiliaryArray[j]]);\r\n        mainArray[k++] = auxiliaryArray[j++];\r\n      }\r\n    }\r\n  }\r\n  while (i <= middleIdx) {\r\n    // These are the values that we're comparing; we push them once\r\n    // to change their color.\r\n    animations.push([i, i]);\r\n    // These are the values that we're comparing; we push them a second\r\n    // time to revert their color.\r\n    animations.push([i, i]);\r\n    // We overwrite the value at index k in the original array with the\r\n    // value at index i in the auxiliary array.\r\n    animations.push([k, auxiliaryArray[i]]);\r\n    mainArray[k++] = auxiliaryArray[i++];\r\n  }\r\n  while (j <= endIdx) {\r\n    // These are the values that we're comparing; we push them once\r\n    // to change their color.\r\n    animations.push([j, j]);\r\n    // These are the values that we're comparing; we push them a second\r\n    // time to revert their color.\r\n    animations.push([j, j]);\r\n    // We overwrite the value at index k in the original array with the\r\n    // value at index j in the auxiliary array.\r\n    animations.push([k, auxiliaryArray[j]]);\r\n    mainArray[k++] = auxiliaryArray[j++];\r\n  }\r\n}\r\n",{"ruleId":"30","replacedBy":"31"},{"ruleId":"32","replacedBy":"33"},{"ruleId":"34","severity":1,"message":"35","line":27,"column":6,"nodeType":"36","endLine":27,"endColumn":14,"suggestions":"37"},{"ruleId":"38","severity":1,"message":"39","line":74,"column":9,"nodeType":"40","messageId":"41","endLine":74,"endColumn":21},{"ruleId":"38","severity":1,"message":"42","line":116,"column":11,"nodeType":"40","messageId":"41","endLine":116,"endColumn":22},{"ruleId":"43","severity":1,"message":"44","line":131,"column":15,"nodeType":"45","messageId":"46","endLine":131,"endColumn":17},"no-native-reassign",["47"],"no-negated-in-lhs",["48"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'resetArray'. Either include it or remove the dependency array.","ArrayExpression",["49"],"no-unused-vars","'stopAndReset' is assigned a value but never used.","Identifier","unusedVar","'animations2' is assigned a value but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","no-global-assign","no-unsafe-negation",{"desc":"50","fix":"51"},"Update the dependencies array to be: [resetArray, slider]",{"range":"52","text":"53"},[818,826],"[resetArray, slider]"]